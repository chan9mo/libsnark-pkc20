/*******************************************************************************
 * Author: Seongho Park <shparkk95@kookmin.ac.kr>
 *******************************************************************************/

package examples.gadgets.diffieHellmanKeyExchange;

import java.math.BigInteger;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import util.Util;
import java.util.Map;
import java.util.Set;

import javax.crypto.SecretKey;

import org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions;

import circuit.structure.BigIntegerAffinePoint;
import circuit.config.Config;

/**
 * This gadget implements cryptographic key exchange using a customized elliptic
 * curve that is efficient to represent as a SNARK circuit. It follows the
 * high-level guidelines used for the design of Curve25519, while having the
 * cost model of QAP-based SNARKs in mind. Details in section 6:
 * https://eprint.iacr.org/2015/1093.pdf
 * 
 * Detailed comments about the inputs and outputs of the circuit are below.
 * 
 * Note: By default, this gadget validates only the secret values that are
 * provided by the prover, such as the secret key, and any intermediate
 * auxiliary witnesses that the prover uses in the circuit. In the default mode,
 * the gadget does not check the public input keys, e.g. it does not verify that
 * the base point or the other party's input have the appropriate order, as such
 * inputs could be typically public and can be checked outside the circuit if
 * needed. The Curve25519 paper as well claims that validation is not necessary
 * (although there is debate about some cases online). If any validation is
 * desired, there is a separate method called validateInputs() that do
 * validation, but is not called by default.
 * 
 * 
 * 
 */

public class BigIntegerEC {

    // Note: this parameterization assumes that the underlying field has
    // Config.FIELD_PRIME =
    // 21888242871839275222246405745257275088548364400416034343698204186575808495617

    public final static int SECRET_BITWIDTH = 254; // number of bits in the
                                                   // exponent. Note that the
                                                   // most significant bit
                                                   // should
                                                   // be set to 1, and the
                                                   // three least significant
                                                   // bits should be be zero.
                                                   // See
                                                   // the constructor

    public final static BigInteger COEFF_A = new BigInteger("126932"); // parameterization
                                                                       // in
                                                                       // https://eprint.iacr.org/2015/1093.pdf

    public final static BigInteger CURVE_ORDER = new BigInteger(
            "21888242871839275222246405745257275088597270486034011716802747351550446453784");

    // As in curve25519, CURVE_ORDER = SUBGROUP_ORDER * 2^3
    public final static BigInteger SUBGROUP_ORDER = new BigInteger(
            "2736030358979909402780800718157159386074658810754251464600343418943805806723");

    // The Affine point representation is used as it saves one gate per bit
    private BigIntegerAffinePoint basePoint; // The Base point both parties agree to
    private BigIntegerAffinePoint hPoint; // H is the other party's public value
                                // H = (other party's secret)* Base <- scalar EC
                                // multiplication

    private BigInteger[] secretBits; // the bits of the secret generated by this party
                               // (follows little-endian order)

    // gadget outputs
    private BigInteger outputPublicValue; // the x-coordinate of the key exchange
                                    // material to be sent to the other party
                                    // outputPublicValue = ((this party's
                                    // secret)*Base).x

    private BigInteger sharedSecret; // the x-coordinate of the derived key ((this
                               // party's secret)*H).x

    private BigIntegerAffinePoint[] baseTable;
    private BigIntegerAffinePoint[] hTable;

   

    /**
     * This gadget receives two points: Base = (baseX) and H = (hX), and the secret
     * key Bits and outputs the scalar EC multiplications: secret*Base, secret*H
     * 
     * The secret key bits must be of length SECRET_BITWIDTH and are expected to
     * follow a little endian order. The most significant bit should be 1, and the
     * three least significant bits should be zero.
     * 
     * This gadget can work with both static and dynamic inputs If public keys are
     * static, the BigIntegers of base and h should be made ConstantBigIntegers when creating
     * them (before calling this gadget).
     * 
     * 
     */
    public static BigInteger[] makesecretbits(BigInteger input){
        
        input = input.mod(Config.CURVE_ORDER);
        BigInteger[] temp = Util.zeropadBigIntegers(Util.split(input, 1), SECRET_BITWIDTH);
        BigInteger[] output = new BigInteger[SECRET_BITWIDTH];
        System.arraycopy(temp, 0, output, 3, temp.length);
		return output;
    }

    public BigIntegerEC(BigInteger baseX, BigInteger secretBits, String... path) {
        this.secretBits = makesecretbits(secretBits);
        this.basePoint = new BigIntegerAffinePoint(baseX);
        // this.hPoint = new BigIntegerAffinePoint(hX);
        // checkSecretBits();
        computeYCoordinates(); // For efficiency reasons, we rely on affine
                               // coordinate      
    }


    public BigInteger getOutput(){
        baseTable = preprocess(basePoint);
        outputPublicValue = mul(basePoint, secretBits, baseTable).x;
        return outputPublicValue.mod(Config.FIELD_PRIME);
    }


    private void checkSecretBits() {
        /**
         * The secret key bits must be of length SECRET_BITWIDTH and are expected to
         * follow a little endian order. The most significant bit should be 1, and the
         * three least significant bits should be zero.
         */

        if (secretBits.length != SECRET_BITWIDTH) {
            throw new IllegalArgumentException();
        }
        //if(secretBits[0].compareTo(BigInteger.ZERO) != 0) System.out.println("Asserting secret bit conditions 0");
        //if(secretBits[1].compareTo(BigInteger.ZERO) != 0) System.out.println("Asserting secret bit conditions 1");
        //if(secretBits[2].compareTo(BigInteger.ZERO) != 0) System.out.println("Asserting secret bit conditions 2");
        //if(secretBits[SECRET_BITWIDTH - 1].compareTo(BigInteger.ONE) != 0) System.out.println("Asserting secret bit conditions 3");
    }

    private void computeYCoordinates() {
        BigInteger x = (basePoint.x);
        basePoint.y = computeYCoordinate(x);
    }

    // this is only called, when BigInteger y is provided as witness by the prover
    // (not as input to the gadget)
    private void assertValidPointOnEC(BigInteger x, BigInteger y) {
        BigInteger ySqr = y.multiply(y);
        BigInteger xSqr = x.multiply(x);
        BigInteger xCube = xSqr.multiply(x);
        assert (ySqr == xCube.add(xSqr.multiply(COEFF_A)).add(x)) : "not valid ec point!";
        
    }


    private BigIntegerAffinePoint[] preprocess(BigIntegerAffinePoint p) {
        BigIntegerAffinePoint[] precomputedTable = new BigIntegerAffinePoint[secretBits.length+1];
        precomputedTable[0] = p;
        for (int j = 1; j <= secretBits.length; j += 1) {
            precomputedTable[j] = doubleBigIntegerAffinePoint(precomputedTable[j - 1]);
        }
        return precomputedTable;
    }

    public BigIntegerAffinePoint[] getprecomputedTable(){
        return baseTable;
    }

    /**
     * Performs scalar multiplication (secretBits must comply with the conditions
     * above)
     */
    public BigIntegerAffinePoint mul(BigIntegerAffinePoint p, BigInteger[] secretBits, BigIntegerAffinePoint[] precomputedTable) {

        BigIntegerAffinePoint result = new BigIntegerAffinePoint(precomputedTable[secretBits.length]);
        for (int j = secretBits.length - 1; j >= 0; j--) {
            BigIntegerAffinePoint tmp = addBigIntegerAffinePoints(result, precomputedTable[j]);
            
            BigInteger isOne = secretBits[j];

            result.x = result.x.add(isOne.multiply(tmp.x.subtract(result.x))).mod(Config.FIELD_PRIME);
            result.y = result.y.add(isOne.multiply(tmp.y.subtract(result.y))).mod(Config.FIELD_PRIME);
        }
        result = subAffinePoints(result, precomputedTable[secretBits.length]);

        return result;
    }

    public BigIntegerAffinePoint doubleBigIntegerAffinePoint(BigIntegerAffinePoint p) {
        BigInteger three = new BigInteger("3");
        BigInteger two = new BigInteger("2");
        BigInteger x_2 = p.x.multiply(p.x);
        BigInteger l1 = FieldDivision(x_2.multiply(three).add(p.x.multiply(COEFF_A).multiply(two)).add(BigInteger.ONE), p.y.multiply(two));
        BigInteger l2 = l1.multiply(l1);
        BigInteger newX = l2.subtract(COEFF_A).subtract(p.x).subtract(p.x);
        BigInteger newY = p.x.multiply(three).add(COEFF_A).subtract(l2).multiply(l1).subtract(p.y);
        return new BigIntegerAffinePoint(newX.mod(Config.FIELD_PRIME), newY.mod(Config.FIELD_PRIME));
    }

    public static BigIntegerAffinePoint addBigIntegerAffinePoints(BigIntegerAffinePoint p1, BigIntegerAffinePoint p2) {
        BigInteger two = new BigInteger("2");
        BigInteger diffY = p1.y.subtract(p2.y);
        BigInteger diffX = p1.x.subtract(p2.x);
        BigInteger q = FieldDivision(diffY, diffX);
        BigInteger q2 = q.multiply(q);
        BigInteger q3 = q2.multiply(q);
        BigInteger newX = q2.subtract(COEFF_A).subtract(p1.x).subtract(p2.x);
        BigInteger newY = p1.x.multiply(two).add(p2.x).add(COEFF_A).multiply(q).subtract(q3).subtract(p1.y);
        return new BigIntegerAffinePoint(newX.mod(Config.FIELD_PRIME), newY.mod(Config.FIELD_PRIME));
    }

    public static BigInteger FieldDivision(BigInteger a, BigInteger b){
        BigInteger c = a.multiply(b.modInverse(Config.FIELD_PRIME).mod(Config.FIELD_PRIME));
        return c;
    }

    private BigIntegerAffinePoint subAffinePoints(BigIntegerAffinePoint p1, BigIntegerAffinePoint p2) {
        BigInteger two = new BigInteger("2");
        BigInteger diffY = p1.y.add(p2.y);
        BigInteger diffX = p1.x.subtract(p2.x);
        BigInteger q = FieldDivision(diffY, diffX);
        BigInteger q2 = q.multiply(q);
        BigInteger q3 = q2.multiply(q);
        BigInteger newX = q2.subtract(COEFF_A).subtract(p1.x).subtract(p2.x);
        BigInteger newY = p1.x.multiply(two).add(p2.x).add(COEFF_A).multiply(q).subtract(q3).subtract(p1.y);
        return new BigIntegerAffinePoint(newX.mod(Config.FIELD_PRIME), newY.mod(Config.FIELD_PRIME));
    }

    public static BigInteger computeYCoordinate(BigInteger x) {
        BigInteger xSqred = x.multiply(x).mod(Config.FIELD_PRIME);
        BigInteger xCubed = xSqred.multiply(x).mod(Config.FIELD_PRIME);
        BigInteger ySqred = xCubed.add(COEFF_A.multiply(xSqred)).add(x).mod(Config.FIELD_PRIME);
        BigInteger y = IntegerFunctions.ressol(ySqred, Config.FIELD_PRIME);
        return y.mod(Config.FIELD_PRIME);
    }

    public void validateInputs() {
        assertValidPointOnEC(basePoint.x, basePoint.y);
        assertPointOrder(basePoint, baseTable);
        // generator.addOneAssertion(hPoint.x.checkNonZero());
        // assertValidPointOnEC(hPoint.x, hPoint.y);
        // assertPointOrder(basePoint, baseTable);
        // assertPointOrder(hPoint, hTable);
    }

    private void assertPointOrder(BigIntegerAffinePoint p, BigIntegerAffinePoint[] table) {

        BigInteger o = SUBGROUP_ORDER;
        BigInteger[] bits = Util.split(SUBGROUP_ORDER, 1);

        BigIntegerAffinePoint result = new BigIntegerAffinePoint(table[bits.length - 1]);
        for (int j = bits.length - 2; j >= 1; j--) {
            BigIntegerAffinePoint tmp = addBigIntegerAffinePoints(result, table[j]);
            BigInteger isOne = secretBits[j];
            result.x = result.x.add(isOne.multiply(tmp.x.subtract(result.x)));
            result.y = result.y.add(isOne.multiply(tmp.y.subtract(result.y)));
        }

        // verify that: result = -p
        assert (result.x == p.x) : "x is not equal";
        assert (result.y == p.y.multiply(BigInteger.valueOf(-1))) : "y is not equal";
        

        // the reason the last iteration is handled separately is that the
        // addition of
        // affine points will throw an error due to not finding inverse for zero
        // at the last iteration of the scalar multiplication. So, the check in
        // the last iteration is done manually

        // TODO: add more tests to check this method

    }
    
    

    public static void main(String[] args) throws Exception{
        BigInteger G = new BigInteger("10398164868948269691505217409040279103932722394566360325611713252123766059173");
        BigInteger rho = new BigInteger("2044447821227135049546360292227461002013328657554503008869211189680158891511");

        BigIntegerEC U = new BigIntegerEC(G, rho);

        BigInteger s = new BigInteger("234444782122713504954636029222746100201332865755450300886921118968015889151");

        BigIntegerEC S = new BigIntegerEC(G, s);

        BigIntegerEC srho = new BigIntegerEC(S.getOutput(), rho);
        BigInteger sr = srho.getOutput();
        
        BigIntegerEC Greal = new BigIntegerEC(G, new BigInteger("3224"));
        BigInteger gr = Greal.getOutput();
        
        BigIntegerAffinePoint a = new BigIntegerAffinePoint(sr);
        a.y = computeYCoordinate(sr);
        BigIntegerAffinePoint b = new BigIntegerAffinePoint(gr);
        b.y = computeYCoordinate(gr);
        BigInteger T = addBigIntegerAffinePoints(a, b).x;
        
        BigInteger srhoplusone = rho.multiply(s).mod(Config.CURVE_ORDER).add(new BigInteger("3224"));
        System.out.println("sr+1\t" + srhoplusone);
        BigIntegerEC makeT = new BigIntegerEC(G, srhoplusone);

        System.out.println("G : " + G);
        System.out.println("rho : " + rho);  
        System.out.println("");
        System.out.println("U : " + U.getOutput());
        System.out.println("s : " + s);  
        System.out.println("S : " + S.getOutput());
        System.out.println("T : " + makeT.getOutput());
        System.out.println("T : " + T);

    }
}

